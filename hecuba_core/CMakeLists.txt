cmake_minimum_required(VERSION 3.3)

list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake) #folder with FindCmakes

set(CORE_SRC_DIR "${CMAKE_SOURCE_DIR}/src")
#set(CORE_INCLUDE_DIR "${CMAKE_SOURCE_DIR}/include")

project(hecuba_core)


include(ExternalProject)


# Compiler related configuration
set(CMAKE_CXX_STANDARD 11)

#If the default compiler doesn't support C++11, set the environment vars [CC,CXX] pointing to the compilers binaries
# desired to compile C and C++ respectively
IF (NOT CMAKE_CONFIGURATION_TYPES AND NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release) #Release|Debug|RelWithDebInfo|MinSizeRel
ENDIF (NOT CMAKE_CONFIGURATION_TYPES AND NOT CMAKE_BUILD_TYPE)

#set(ENABLE_PRECOMPILED_HEADERS OFF) to skip headers



#get_property(dirs DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY INCLUDE_DIRECTORIES)
#foreach (dir ${dirs})
#    message(STATUS "Dir for includes='${dir}'")
#endforeach ()

message("CMAKE_BUILD_TYPE is ${CMAKE_BUILD_TYPE}")


set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)


#Add environment $CPLUS_INCLUDE_PATH include paths
if (NOT $ENV{CPLUS_INCLUDE_PATH} STREQUAL "")
    string(REPLACE ":" " " INCLUDES $ENV{CPLUS_INCLUDE_PATH})
    string(REPLACE "//" "/" INCLUDES ${INCLUDES})
    string(REGEX MATCHALL "[^ ]+" LIST_INCLUDES ${INCLUDES})
endif (NOT $ENV{CPLUS_INCLUDE_PATH} STREQUAL "")
include_directories(${LIST_INCLUDES})


#Add environment $C_INCLUDE_PATH include paths
if (NOT $ENV{C_INCLUDE_PATH} STREQUAL "")
    string(REPLACE ":" " " INCLUDES $ENV{C_INCLUDE_PATH})
    string(REPLACE "//" "/" INCLUDES ${INCLUDES})
    string(REGEX MATCHALL "[^ ]+" LIST_INCLUDES ${INCLUDES})
endif (NOT $ENV{C_INCLUDE_PATH} STREQUAL "")
include_directories(${LIST_INCLUDES})


#Add environment $CPATH include paths
if (NOT $ENV{CPATH} STREQUAL "")
    string(REPLACE ":" " " INCLUDES $ENV{CPATH})
    string(REPLACE "//" "/" INCLUDES ${INCLUDES})
    string(REGEX MATCHALL "[^ ]+" LIST_INCLUDES ${INCLUDES})
endif (NOT $ENV{CPATH} STREQUAL "")
include_directories(${LIST_INCLUDES})

#Add includes generated by this project
include_directories(${PROJECT_BINARY_DIR}/include)


#LD_LIBRARY being picked by the compiler (probably)
if (NOT $ENV{LD_LIBRARY_PATH} STREQUAL "")
    string(REPLACE ":" " " ENV_LIBS $ENV{LD_LIBRARY_PATH})
    string(REPLACE "//" "/" ENV_LIBS ${ENV_LIBS})
    string(REGEX MATCHALL "[^ ]+" LIST_LIBS ${ENV_LIBS})
endif (NOT $ENV{LD_LIBRARY_PATH} STREQUAL "")



# SUBPROJECTS

#if the user has set custom compiler paths, forward to submodules
if (${CC})
    set(CMAKE_SUBPROJECT_FLAGS ${CMAKE_SUBPROJECT_FLAGS} " -DCMAKE_C_COMPILER=${CC}")
endif ()

if (${CXX})
    set(CMAKE_SUBPROJECT_FLAGS ${CMAKE_SUBPROJECT_FLAGS} " -DCMAKE_CXX_COMPILER=${CXX}")
endif ()





#LINK DIRECTORIES discouraged, not working properly sometimes
LINK_DIRECTORIES(${PROJECT_BINARY_DIR}/lib64 ${PROJECT_BINARY_DIR}/lib)
message("BIN DIR ${PROJECT_BINARY_DIR}")


# SOURCES

file(GLOB CORE_H_FILES ${CORE_SRC_DIR}/*.h)
file(GLOB CORE_SRC_FILES ${CORE_SRC_DIR}/*.cpp)
set(HEADER_FILES ${CORE_H_FILES})
set(SOURCE_FILES ${CORE_SRC_FILES})

#set(CMAKE_SKIP_RPATH 1)
#set(MY_PATHS "${ORIGIN}")
#CMake main target

# use, i.e. don't skip the full RPATH for the build tree
SET(CMAKE_SKIP_BUILD_RPATH FALSE)

# when building, don't use the install RPATH already
# (but later on when installing)
SET(CMAKE_BUILD_WITH_INSTALL_RPATH TRUE)

# don't add the automatically determined parts of the RPATH
# which point to directories outside the build tree to the install RPATH
SET(CMAKE_INSTALL_RPATH_USE_LINK_PATH FALSE)


add_library(hfetch SHARED ${SOURCE_FILES} ${HEADER_FILES})
set_target_properties(hfetch
        PROPERTIES
	#	PREFIX ""
        INSTALL_RPATH "$ORIGIN/"
        BUILD_WITH_INSTALL_RPATH 1)



# Compile options

#set(CMAKE_CXX_FLAGS_RELEASE "-O3 -Wall")
target_compile_options(hfetch PUBLIC $<$<COMPILE_LANGUAGE:CXX>:-Wall>)
set_property(TARGET hfetch PROPERTY POSITION_INDEPENDENT_CODE ON) # Add -fPIC option


#Dependencies
FIND_LIBRARY(CASS NAMES cassandra PATHS ${PROJECT_BINARY_DIR}/lib)
FIND_LIBRARY(LIBUV NAMES uv PATHS ${PROJECT_BINARY_DIR}/lib)


IF (NOT LIBUV)
    message("Downloading LIBUV (requisite for Cassandra C++ driver)")
    unset(LIBUV) #to avoid name clash
    ExternalProject_Add(
            LIBUV
            DOWNLOAD_DIR ${CMAKE_CURRENT_LIST_DIR}/dependencies
            URL "https://github.com/libuv/libuv/archive/v1.11.0.tar.gz"
            URL_HASH SHA1=54f0972aa0d3f6a6036d477b381c01f030f9a2b5
            CMAKE_COMMAND echo
            BUILD_COMMAND sh autogen.sh COMMAND ./configure --prefix=${PROJECT_BINARY_DIR}
            BUILD_IN_SOURCE 1
            INSTALL_COMMAND make COMMAND make install
    )
    set(LIBUV_EXTERNAL LIBUV)
    add_dependencies(hfetch LIBUV)
    target_link_libraries(hfetch uv)
else ()
    set(LIBUV_EXTERNAL)
    message(STATUS "Using system's LIBUV: " ${LIBUV})
    set(ALL_LIBS ${ALL_LIBS} ${LIBUV})
endif ()


if (NOT CASS)
    message("Downloading C++ Cassandra Driver")
    unset(CASS) #to avoid name clash
    ExternalProject_Add(
            CASS
            DEPENDS ${LIBUV_EXTERNAL}
            DOWNLOAD_DIR ${CMAKE_CURRENT_LIST_DIR}/dependencies
            URL https://github.com/datastax/cpp-driver/archive/2.7.1.tar.gz
            URL_HASH SHA1=7a44eff7eecbb3ed95490d09cd00489c5b5ce683
            INSTALL_DIR ${PROJECT_BINARY_DIR}
            CMAKE_ARGS ${CMAKE_SUBPROJECT_FLAGS}
            -DCMAKE_INSTALL_PREFIX=${PROJECT_BINARY_DIR} -DCASS_USE_LIBSSH2=OFF -DCASS_USE_OPENSSL=OFF
    )
    add_dependencies(hfetch CASS)
    set(ALL_LIBS ${ALL_LIBS} ${PROJECT_BINARY_DIR}/lib/libcassandra.so)
else ()
    message(STATUS "Using system's C++ Cassandra driver: " ${CASS})
    set(ALL_LIBS ${ALL_LIBS} ${CASS})
endif ()


# FIND PACKAGES

FIND_PACKAGE(TBB) # searches for the system TBB

if (NOT TBB_FOUND)
    set(TBB_ROOT_DIR ${PROJECT_BINARY_DIR})
    set(TBB_LIBRARY ${PROJECT_BINARY_DIR}/lib)
    set(TBB_INCLUDE_DIR ${PROJECT_BINARY_DIR}/include)
    message(STATUS "TBB libraries not found, using downloaded TBB")
    FIND_PACKAGE(TBB)
endif ()


if (NOT TBB_FOUND)
    message("Downloading Intel TBB")
    unset(TBB)
    set(build_prefix tbb_prefix)
    ExternalProject_Add(
            TBB
            DOWNLOAD_DIR ${CMAKE_CURRENT_LIST_DIR}/dependencies
            URL "https://www.threadingbuildingblocks.org/sites/default/files/software_releases/source/tbb2017_20161128oss_src.tgz"
            URL_HASH SHA1=2c451a5bcf6fc31487b98b4b29651c369874277c
            CMAKE_COMMAND echo
            BUILD_COMMAND make tbb tbb_build_prefix=${build_prefix}
            BUILD_IN_SOURCE 1
            INSTALL_COMMAND mkdir -p ${PROJECT_BINARY_DIR}/lib
            COMMAND mkdir -p ${PROJECT_BINARY_DIR}/include
            COMMAND cp -r build/${build_prefix}_release/libtbb.so build/${build_prefix}_release/libtbb.so.2 ${PROJECT_BINARY_DIR}/lib
            COMMAND cp -r include/tbb ${PROJECT_BINARY_DIR}/include
    )
    add_dependencies(hfetch TBB)
    set(ALL_LIBS ${ALL_LIBS} ${PROJECT_BINARY_DIR}/lib/libtbb.so)
else ()
    message(STATUS "Using system's TBB: " ${TBB_LIBRARIES})
    set(ALL_LIBS ${ALL_LIBS} ${TBB_LIBRARIES})
    include_directories(${TBB_INCLUDE_DIRS})
endif ()



target_link_libraries(hfetch ${ALL_LIBS})



if (DEFINED ENV{GTEST_ROOT})
    #Tests dependencies
    FIND_LIBRARY(PT NAMES pthread PATHS /lib)
    if (PT)
        find_package(GTest)
        if (GTest_FOUND)
            include_directories(${GTEST_INCLUDE_DIRS})

            enable_testing()

            add_executable(hfetch_test tests/runtests.cpp)
            set_target_properties(hfetch_test
                    PROPERTIES BUILD_WITH_INSTALL_RPATH 0)
            target_link_libraries(hfetch_test ${ALL_LIBS} ${PT} ${GTEST_BOTH_LIBRARIES} hfetch)
            add_test(test hfetch_test)

            add_executable(cache_imp_test tests/cache_tests.cpp)
            set_target_properties(cache_imp_test
                    PROPERTIES BUILD_WITH_INSTALL_RPATH 0)
            target_link_libraries(cache_imp_test ${ALL_LIBS} ${PT} ${GTEST_BOTH_LIBRARIES} hfetch)
            add_test(test cache_imp_test)

            find_package(PythonInterp 2.7)
            find_package(PythonLibs 2.7.5 REQUIRED)
            find_package(NumPy 1.8)

            if (NUMPY_FOUND)
                include_directories(${NUMPY_INCLUDE_DIR})
            else ()
                message("Numpy headers not found, Numpy arrays support won't be available")
            endif ()

            include_directories(${PYTHON_INCLUDE_DIRS})
            set(ALL_LIBS ${ALL_LIBS} ${PYTHON_LIBRARIES})


            file(GLOB COREPY_H_FILES ${CORE_SRC_DIR}/py_interface/*.h)
            file(GLOB COREPY_SRC_FILES ${CORE_SRC_DIR}/py_interface/*.cpp)
            set(PY_H_FILES ${COREPY_H_FILES})
            set(PY_SRC_FILES ${COREPY_SRC_FILES})

            #set(PY_SRC_FILES py_interface/HCache.cpp PythonParser.cpp UnitParser.cpp NumpyStorage.cpp)
            #set(PY_H_FILES HCache.h PythonParser.h UnitParser.h NumpyStorage.h)
            add_library(pyinterface SHARED ${PY_SRC_FILES} ${PY_H_FILES})
            set_target_properties(pyinterface
                    PROPERTIES PREFIX ""
                    INSTALL_RPATH "$ORIGIN/"
                    BUILD_WITH_INSTALL_RPATH 1)
            target_link_libraries(pyinterface ${ALL_LIBS})


            add_executable(py_hfetch_test tests/pytests.cpp)
            set_target_properties(py_hfetch_test
                    PROPERTIES BUILD_WITH_INSTALL_RPATH 0)
            target_link_libraries(py_hfetch_test ${ALL_LIBS} ${PT} ${GTEST_BOTH_LIBRARIES} hfetch pyinterface)
            add_test(test py_hfetch_test)

        else ()
            message(STATUS "If GTest is installed, point the environment var GTEST_ROOT to its root (/home/user/local)")
        endif (GTest_FOUND)
    endif (PT)
endif (DEFINED ENV{GTEST_ROOT})
